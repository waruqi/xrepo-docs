<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xrepo</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xrepo.xmake.io/#/">https://xrepo.xmake.io/#/</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <h2 id="">简介</h2>
<p>XMake是一个基于Lua的轻量级跨平台自动构建工具，支持在各种主流平台上构建项目</p>
<p>xmake的目标是开发者更加关注于项目本身开发，简化项目的描述和构建，并且提供平台无关性，使得一次编写，随处构建</p>
<p>它跟cmake、automake、premake有点类似，但是机制不同，它默认不会去生成IDE相关的工程文件，采用直接编译，并且更加的方便易用<br>采用lua的工程描述语法更简洁直观，支持在大部分常用平台上进行构建，以及交叉编译</p>
<p>并且xmake提供了创建、配置、编译、打包、安装、卸载、运行等一些actions，使得开发和构建更加的方便和流程化。</p>
<p>不仅如此，它还提供了许多更加高级的特性，例如插件扩展、脚本宏记录、批量打包、自动文档生成等等。。</p>
<h2 id="">安装</h2>
<h4 id="master">Master版本</h4>
<h4 id="curl">使用curl</h4>
<pre><code class="lang-bash">bash <(curl -fsSL https://xmake.io/shget.text)
</code></pre>
<h4 id="wget">使用wget</h4>
<pre><code class="lang-bash">bash <(wget https://xmake.io/shget.text -O -)
</code></pre>
<h4 id="powershell">使用powershell</h4>
<pre><code class="lang-powershell">Invoke-Expression (Invoke-Webrequest &#39;https://xmake.io/psget.text&#39; -UseBasicParsing).Content
</code></pre>
<h4 id="windows">Windows</h4>
<h5 id="">使用安装包</h5>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载windows安装包</li>
<li>运行安装程序 xmake-[version].exe</li>
</ol>
<h5 id="scoop">使用scoop</h5>
<pre><code class="lang-bash">scoop install xmake
</code></pre>
<h4 id="macos">MacOS</h4>
<pre><code class="lang-bash">$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
$ brew install xmake
</code></pre>
<p>或者：</p>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载pkg安装包</li>
<li>双击运行</li>
</ol>
<p>或者安装master版本:</p>
<pre><code class="lang-bash"># 使用homebrew安装master版本
$ brew install xmake --HEAD

# 或者直接调用shell下载安装
$ bash <(curl -fsSL https://xmake.io/shget.text)
</code></pre>
<h4 id="linux">Linux</h4>
<p>在archlinux上安装：</p>
<pre><code class="lang-bash">$ yaourt xmake
</code></pre>
<p>在ubuntu上安装：</p>
<pre><code class="lang-bash">$ sudo add-apt-repository ppa:tboox/xmake
$ sudo apt-get update
$ sudo apt-get install xmake
</code></pre>
<p>或者手动添加包源：</p>
<pre><code>deb http://ppa.launchpad.net/tboox/xmake/ubuntu yakkety main 
deb-src http://ppa.launchpad.net/tboox/xmake/ubuntu yakkety main 
</code></pre><p>然后执行：</p>
<pre><code class="lang-bash">$ sudo apt-get update
$ sudo apt-get install xmake
</code></pre>
<p>或者下载deb包来安装：</p>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载deb安装包</li>
<li>运行: <code>dpkg -i xmake-xxxx.deb</code></li>
</ol>
<p>在<code>redhat/centos</code>上安装：</p>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载rpm安装包</li>
<li>运行: <code>yum install xmake-xxx.rpm --nogpgcheck</code></li>
</ol>
<h4 id="">编译安装</h4>
<p>通过脚本编译安装:</p>
<pre><code class="lang-bash">$ git clone https://github.com/xmake-io/xmake.git
$ cd ./xmake
$ ./scripts/get.sh __local__
</code></pre>
<p>仅仅安装和更新xmake的lua脚本:</p>
<pre><code class="lang-bash">$ ./scripts/get.sh __local__ __install_only__
</code></pre>
<p>卸载:</p>
<pre><code class="lang-bash">$ ./scripts/get.sh __uninstall__
</code></pre>
<p>通过make进行编译安装:</p>
<pre><code class="lang-bash">$ make build; sudo make install
</code></pre>
<p>安装到其他指定目录:</p>
<pre><code class="lang-bash">$ sudo make install prefix=/usr/local
</code></pre>
<p>卸载:</p>
<pre><code class="lang-bash">$ sudo make uninstall
</code></pre>
<h4 id="">更新升级</h4>
<p>从v2.2.3版本开始，新增了<code>xmake update</code>命令，来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个版本：</p>
<pre><code class="lang-bash">$ xmake update 2.2.4
</code></pre>
<p>我们也可以指定更新到master/dev分支版本：</p>
<pre><code class="lang-bash">$ xmake update master
$ xmake update dev
</code></pre>
<p>最后，我们如果要卸载xmake，也是支持的：<code>xmake update --uninstall</code></p>
<h2 id="">快速开始</h2>
<p><a href="https://asciinema.org/a/133693"><img src="https://asciinema.org/a/133693.png" alt="asciicast"></a></p>
<h4 id="">创建工程</h4>
<p>创建一个名叫<code>hello</code>的<code>c</code>控制台工程：</p>
<pre><code class="lang-bash">$ xmake create -l c -P ./hello
</code></pre>
<p>执行完后，将会生成一个简单工程结构：</p>
<pre><code>hello
├── src
│   └── main.c
└── xmake.lua
</code></pre><p>其中<code>xmake.lua</code>是工程描述文件，内容非常简单，告诉xmake添加<code>src</code>目录下的所有<code>.c</code>源文件：</p>
<pre><code class="lang-lua">target("hello")
    set_kind("binary")
    add_files("src/*.c") 
</code></pre>
<p>目前支持的语言如下：</p>
<ul>
<li>c/c++</li>
<li>objc/c++</li>
<li>cuda</li>
<li>asm</li>
<li>swift</li>
<li>dlang</li>
<li>golang</li>
<li>rust</li>
</ul>
<p><p class="tip"><br>    如果你想了解更多参数选项，请运行: <code>xmake create --help</code><br></p>

</p>
<h4 id="">构建工程</h4>
<pre><code class="lang-bash">$ xmake
</code></pre>
<h4 id="">运行程序</h4>
<pre><code class="lang-bash">$ xmake run hello
</code></pre>
<h4 id="">调试程序</h4>
<pre><code class="lang-bash">$ xmake run -d hello 
</code></pre>
<p>xmake将会使用系统自带的调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。</p>
<pre><code class="lang-bash">[lldb]$target create "build/hello"
Current executable set to &#39;build/hello&#39; (x86_64).
[lldb]$b main
Breakpoint 1: where = hello`main, address = 0x0000000100000f50
[lldb]$r
Process 7509 launched: &#39;/private/tmp/hello/build/hello&#39; (x86_64)
Process 7509 stopped
* thread #1: tid = 0x435a2, 0x0000000100000f50 hello`main, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1
    frame #0: 0x0000000100000f50 hello`main
hello`main:
->  0x100000f50 <+0>:  pushq  %rbp
    0x100000f51 <+1>:  movq   %rsp, %rbp
    0x100000f54 <+4>:  leaq   0x2b(%rip), %rdi          ; "hello world!"
    0x100000f5b <+11>: callq  0x100000f64               ; symbol stub for: puts
[lldb]$
</code></pre>
<p><p class="tip"><br>    你也可以使用简写的命令行选项，例如: <code>xmake r</code> 或者 <code>xmake run</code><br></p>

</p>
<h2 id="">工程实例</h2>
<h4 id="">可执行程序</h4>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*c")
</code></pre>
<h4 id="">静态库程序</h4>
<pre><code class="lang-lua">target("library")
    set_kind("static")
    add_files("src/library/*.c")

target("test")
    set_kind("binary")
    add_files("src/*c")
    add_deps("library")
</code></pre>
<p>通过<code>add_deps</code>将一个静态库自动链接到test可执行程序。</p>
<h4 id="">动态库程序</h4>
<pre><code class="lang-lua">target("library")
    set_kind("shared")
    add_files("src/library/*.c")

target("test")
    set_kind("binary")
    add_files("src/*c")
    add_deps("library")
</code></pre>
<p>通过<code>add_deps</code>将一个动态库自动链接到test可执行程序。</p>
<h4 id="qt">Qt程序</h4>
<p>创建一个空工程：</p>
<pre><code class="lang-console">$ xmake create -l c++ -t console_qt test
$ xmake create -l c++ -t static_qt test
$ xmake create -l c++ -t shared_qt test
$ xmake create -l c++ -t quickapp_qt test
</code></pre>
<p>默认会自动探测Qt环境，当然也可以指定Qt SDK环境目录：</p>
<pre><code class="lang-console">$ xmake f --qt=~/Qt/Qt5.9.1
</code></pre>
<p>如果想要使用windows下mingw的Qt环境，可以切到mingw的平台配置，并且指定下mingw编译环境的sdk路径即可，例如：</p>
<pre><code class="lang-console">$ xmake f -p mingw --sdk=C:\Qt\Qt5.10.1\Tools\mingw530_32 
</code></pre>
<p>上述指定的mingw sdk用的是Qt下Tools目录自带的环境，当然如果有其他第三方mingw编译环境，也可以手动指定, 具体可以参考：<a href="#mingw">mingw编译配置</a>。</p>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/160">#160</a></p>
<h5 id="">静态库程序</h5>
<pre><code class="lang-lua">target("qt_static_library")
    add_rules("qt.static")
    add_files("src/*.cpp")
    add_frameworks("QtNetwork", "QtGui")
</code></pre>
<h5 id="">动态库程序</h5>
<pre><code class="lang-lua">target("qt_shared_library")
    add_rules("qt.shared")
    add_files("src/*.cpp")
    add_frameworks("QtNetwork", "QtGui")
</code></pre>
<h5 id="">控制台程序</h5>
<pre><code class="lang-lua">target("qt_console")
    add_rules("qt.console")
    add_files("src/*.cpp")
</code></pre>
<h5 id="quick">Quick应用程序</h5>
<pre><code class="lang-lua">target("qt_quickapp")
    add_rules("qt.application")
    add_files("src/*.cpp") 
    add_files("src/qml.qrc")
    add_frameworks("QtQuick")
</code></pre>
<h5 id="widgets">Widgets应用程序</h5>
<pre><code class="lang-lua">target("qt_widgetapp")
    add_rules("qt.application")
    add_files("src/*.cpp") 
    add_files("src/mainwindow.ui")
    add_files("src/mainwindow.h")  -- 添加带有 Q_OBJECT 的meta头文件
    add_frameworks("QtWidgets")
</code></pre>
<h5 id="android">Android应用程序</h5>
<p>2.2.6之后版本，可以直接切到android平台编译Quick/Widgets应用程序，生成apk包，并且可通过<code>xmake install</code>命令安装到设备。</p>
<pre><code class="lang-console">$ xmake create -t quickapp_qt -l c++ appdemo
$ cd appdemo
$ xmake f -p android --ndk=~/Downloads/android-ndk-r19c/ --android_sdk=~/Library/Android/sdk/ -c 
$ xmake
[  0%]: compiling.qt.qrc src/qml.qrc
[ 50%]: ccache compiling.release src/main.cpp
[100%]: linking.release libappdemo.so
[100%]: generating.qt.app appdemo.apk
</code></pre>
<p>然后安装到设备：</p>
<pre><code class="lang-console">$ xmake install
installing appdemo ...
installing build/android/release/appdemo.apk ..
Success
install ok!👌
</code></pre>
<h4 id="cuda">Cuda程序</h4>
<p>创建一个空工程：</p>
<pre><code class="lang-console">$ xmake create -P test -l cuda
$ cd test
$ xmake
</code></pre>
<pre><code class="lang-lua">-- define target
target("cuda_console")
    set_kind("binary")
    add_files("src/*.cu")
    -- generate SASS code for SM architecture of current host
    add_cugencodes("native")
    -- generate PTX code for the virtual architecture to guarantee compatibility
    add_cugencodes("compute_30")
</code></pre>
<p><p class="tip"><br>从v2.2.7版本开始，默认构建会启用device-link。（参见 <a href="https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/">Separate Compilation and Linking of CUDA C++ Device Code</a>）<br>如果要显示禁用device-link，可以通过<code>add_values("cuda.devlink", false)</code> 来设置。<br></p>

</p>
<p>默认会自动探测cuda环境，当然也可以指定Cuda SDK环境目录：</p>
<pre><code class="lang-console">$ xmake f --cuda=/usr/local/cuda-9.1/ 
$ xmake
</code></pre>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/158">#158</a></p>
<h4 id="wdk">WDK驱动程序</h4>
<p>默认会自动探测wdk所在环境，当然也可以指定wdk sdk环境目录：</p>
<pre><code class="lang-console">$ xmake f --wdk="G:\Program Files\Windows Kits\10" -c 
$ xmake
</code></pre>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/159">#159</a></p>
<h5 id="umdf">umdf驱动程序</h5>
<pre><code class="lang-lua">target("echo")
    add_rules("wdk.driver", "wdk.env.umdf")
    add_files("driver/*.c") 
    add_files("driver/*.inx")
    add_includedirs("exe")

target("app")
    add_rules("wdk.binary", "wdk.env.umdf")
    add_files("exe/*.cpp") 
</code></pre>
<h5 id="kmdf">kmdf驱动程序</h5>
<pre><code class="lang-lua">target("nonpnp")
    add_rules("wdk.driver", "wdk.env.kmdf")
    add_values("wdk.tracewpp.flags", "-func:TraceEvents(LEVEL,FLAGS,MSG,...)", "-func:Hexdump((LEVEL,FLAGS,MSG,...))")
    add_files("driver/*.c", {rule = "wdk.tracewpp"}) 
    add_files("driver/*.rc")

target("app")
    add_rules("wdk.binary", "wdk.env.kmdf")
    add_files("exe/*.c") 
    add_files("exe/*.inf")
</code></pre>
<h5 id="wdm">wdm驱动程序</h5>
<pre><code class="lang-lua">target("kcs")
    add_rules("wdk.driver", "wdk.env.wdm")
    add_values("wdk.man.flags", "-prefix Kcs")
    add_values("wdk.man.resource", "kcsCounters.rc")
    add_values("wdk.man.header", "kcsCounters.h")
    add_values("wdk.man.counter_header", "kcsCounters_counters.h")
    add_files("*.c", "*.rc", "*.man") 
</code></pre>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    add_values("wdk.tracewpp.flags", "-func:TracePrint((LEVEL,FLAGS,MSG,...))")
    add_files("*.c", {rule = "wdk.tracewpp"}) 
    add_files("*.rc", "*.inf")
    add_files("*.mof|msdsm.mof")
    add_files("msdsm.mof", {values = {wdk_mof_header = "msdsmwmi.h"}}) 
</code></pre>
<h5 id="">生成驱动包</h5>
<p>可以通过以下命令生成.cab驱动包：</p>
<pre><code class="lang-console">$ xmake [p|package]
$ xmake [p|package] -o outputdir
</code></pre>
<p>输出的目录结构如下：</p>
<pre><code>  - drivers
    - sampledsm
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
</code></pre><h5 id="">驱动签名</h5>
<p>默认编译禁用签名，可以通过<code>set_values("wdk.sign.mode", ...)</code>设置签名模式来启用签名。</p>
<h6 id="">测试签名</h6>
<p>测试签名一般本机调试时候用，可以使用xmake自带的test证书来进行签名，例如：</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
</code></pre>
<p>不过这种情况下，需要用户手动在管理员模式下，执行一遍：<code>$xmake l utils.wdk.testcert install</code>，来生成和注册test证书到本机环境。<br>这个只需要执行一次就行了，后续就可以正常编译和签名了。</p>
<p>当然也可以使用本机已有的有效证书去签名。</p>
<p>从sha1来选择合适的证书进行签名：</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
    set_values("wdk.sign.thumbprint", "032122545DCAA6167B1ADBE5F7FDF07AE2234AAA")
</code></pre>
<p>从store/company来选择合适的证书进行签名：</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
    set_values("wdk.sign.store", "PrivateCertStore")
    set_values("wdk.sign.company", "tboox.org(test)")
</code></pre>
<h6 id="">正式签名</h6>
<p>通过指定对应的正式签名证书文件进行签名：</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "release")
    set_values("wdk.sign.company", "xxxx")
    set_values("wdk.sign.certfile", path.join(os.projectdir(), "xxxx.cer"))
</code></pre>
<h5 id="">生成低版本驱动</h5>
<p>如果想在wdk10环境编译生成win7, win8等低版本系统支持的驱动，可以通过设置<code>wdk.env.winver</code>来切换系统版本：</p>
<pre><code class="lang-lua">set_values("wdk.env.winver", "win10")
set_values("wdk.env.winver", "win10_rs3")
set_values("wdk.env.winver", "win81")
set_values("wdk.env.winver", "win8")
set_values("wdk.env.winver", "win7")
set_values("wdk.env.winver", "win7_sp1")
set_values("wdk.env.winver", "win7_sp2")
set_values("wdk.env.winver", "win7_sp3")
</code></pre>
<p>我们也可以手动指定编译的目标程序支持的windows版本：</p>
<pre><code class="lang-console">$ xmake f --wdk_winver=[win10_rs3|win8|win7|win7_sp1]
$ xmake
</code></pre>
<h4 id="winsdk">WinSDK程序</h4>
<pre><code class="lang-lua">target("usbview")
    add_rules("win.sdk.application")

    add_files("*.c", "*.rc")
    add_files("xmlhelper.cpp", {rule = "win.sdk.dotnet"})
</code></pre>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/173">#173</a></p>
<h2 id="">编译配置</h2>
<p>通过<code>xmake f|config</code>配置命令，设置构建前的相关配置信息，详细参数选项，请运行: <code>xmake f --help</code>。</p>
<p><p class="tip"><br>    你可以使用命令行缩写来简化输入，也可以使用全名，例如: <br><br>    <code>xmake f</code> 或者 <code>xmake config</code>.<br><br>    <code>xmake f -p linux</code> 或者 <code>xmake config --plat=linux</code>.<br></p>

</p>
<h4 id="">目标平台</h4>
<h5 id="">主机平台</h5>
<pre><code class="lang-bash">$ xmake
</code></pre>
<p><p class="tip"><br>    xmake将会自动探测当前主机平台，默认自动生成对应的目标程序。<br></p>

</p>
<h5 id="linux">Linux</h5>
<pre><code class="lang-bash">$ xmake f -p linux [-a i386|x86_64]
$ xmake
</code></pre>
<h5 id="android">Android</h5>
<pre><code class="lang-bash">$ xmake f -p android --ndk=~/files/android-ndk-r10e/ [-a armeabi-v7a|arm64-v8a]
$ xmake
</code></pre>
<p>如果要手动指定ndk中具体某个工具链，而不是使用默认检测的配置，可以通过<a href="#-bin">--bin</a>来设置，例如：</p>
<pre><code class="lang-bash">$ xmake f -p android --ndk=~/files/android-ndk-r10e/ -a arm64-v8a --bin=~/files/android-ndk-r10e/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin
</code></pre>
<p><a href="#-bin">--bin</a>主要用于设置选择编译工具的具体bin目录，这个的使用跟<a href="#交叉编译">交叉编译</a>中的<a href="#-bin">--bin</a>的行为是一致的。</p>
<p><p class="tip"><br>如果手动设置了bin目录，没有通过检测，可以看下是否<code>--arch=</code>参数没有匹配对。<br></p>

</p>
<h5 id="iphoneos">iPhoneOS</h5>
<pre><code class="lang-bash">$ xmake f -p iphoneos [-a armv7|armv7s|arm64|i386|x86_64]
$ xmake
</code></pre>
<h5 id="windows">Windows</h5>
<pre><code class="lang-bash">$ xmake f -p windows [-a x86|x64]
$ xmake
</code></pre>
<h5 id="mingw">Mingw</h5>
<pre><code class="lang-bash">$ xmake f -p mingw --sdk=/usr/local/i386-mingw32-4.3.0/ [-a i386|x86_64]
$ xmake
</code></pre>
<h5 id="applewatchos">Apple WatchOS</h5>
<pre><code class="lang-bash">$ xmake f -p watchos [-a i386|armv7k]
$ xmake
</code></pre>
<h5 id="">交叉编译</h5>
<p>linux平台的交叉编译：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/local/arm-linux-gcc/ [--bin=/sdk/bin] [--cross=arm-linux-]
$ xmake
</code></pre>
<p>其他平台的交叉编译：</p>
<pre><code class="lang-bash">$ xmake f -p cross --sdk=/usr/local/arm-xxx-gcc/ [--bin=/sdk/bin] [--cross=arm-linux-]
$ xmake
</code></pre>
<p>如果不关心实际的平台名，只想交叉编译，可以直接用上面的命令，如果需要通过<code>is_plat("myplat")</code>判断自己的平台逻辑，则：</p>
<pre><code class="lang-bash">$ xmake f -p myplat --sdk=/usr/local/arm-xxx-gcc/ [--bin=/sdk/bin] [--cross=arm-linux-]
$ xmake
</code></pre>
<p>其中：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#-sdk">--sdk</a></td>
<td>设置交叉工具链的sdk根目录</td>
</tr>
<tr>
<td><a href="#-bin">--bin</a></td>
<td>设置工具链bin目录</td>
</tr>
<tr>
<td><a href="#-cross">--cross</a></td>
<td>设置交叉工具链工具前缀</td>
</tr>
<tr>
<td><a href="#-as">--as</a></td>
<td>设置<code>asm</code>汇编器</td>
</tr>
<tr>
<td><a href="#-cc">--cc</a></td>
<td>设置<code>c</code>编译器</td>
</tr>
<tr>
<td><a href="#-cxx">--cxx</a></td>
<td>设置<code>c++</code>编译器</td>
</tr>
<tr>
<td><a href="#-mm">--mm</a></td>
<td>设置<code>objc</code>编译器</td>
</tr>
<tr>
<td><a href="#-mxx">--mxx</a></td>
<td>设置<code>objc++</code>编译器</td>
</tr>
<tr>
<td><a href="#-sc">--sc</a></td>
<td>设置<code>swift</code>编译器</td>
</tr>
<tr>
<td><a href="#-gc">--gc</a></td>
<td>设置<code>golang</code>编译器</td>
</tr>
<tr>
<td><a href="#-dc">--dc</a></td>
<td>设置<code>dlang</code>编译器</td>
</tr>
<tr>
<td><a href="#-rc">--rc</a></td>
<td>设置<code>rust</code>编译器</td>
</tr>
<tr>
<td><a href="#-cu">--cu</a></td>
<td>设置<code>cuda</code>编译器</td>
</tr>
<tr>
<td><a href="#-ld">--ld</a></td>
<td>设置<code>c/c++/objc/asm</code>链接器</td>
</tr>
<tr>
<td><a href="#-sh">--sh</a></td>
<td>设置<code>c/c++/objc/asm</code>共享库链接器</td>
</tr>
<tr>
<td><a href="#-ar">--ar</a></td>
<td>设置<code>c/c++/objc/asm</code>静态库归档器</td>
</tr>
<tr>
<td><a href="#-scld">--scld</a></td>
<td>设置<code>swift</code>链接器</td>
</tr>
<tr>
<td><a href="#-scsh">--scsh</a></td>
<td>设置<code>swift</code>共享库链接器</td>
</tr>
<tr>
<td><a href="#-gcld">--gcld</a></td>
<td>设置<code>golang</code>链接器</td>
</tr>
<tr>
<td><a href="#-gcar">--gcar</a></td>
<td>设置<code>golang</code>静态库归档器</td>
</tr>
<tr>
<td><a href="#-dcld">--dcld</a></td>
<td>设置<code>dlang</code>链接器</td>
</tr>
<tr>
<td><a href="#-dcsh">--dcsh</a></td>
<td>设置<code>dlang</code>共享库链接器</td>
</tr>
<tr>
<td><a href="#-dcar">--dcar</a></td>
<td>设置<code>dlang</code>静态库归档器</td>
</tr>
<tr>
<td><a href="#-rcld">--rcld</a></td>
<td>设置<code>rust</code>链接器</td>
</tr>
<tr>
<td><a href="#-rcsh">--rcsh</a></td>
<td>设置<code>rust</code>共享库链接器</td>
</tr>
<tr>
<td><a href="#-rcar">--rcar</a></td>
<td>设置<code>rust</code>静态库归档器</td>
</tr>
<tr>
<td><a href="#-cu-cxx">--cu-cxx</a></td>
<td>设置<code>cuda</code> host编译器</td>
</tr>
<tr>
<td><a href="#-culd">--culd</a></td>
<td>设置<code>cuda</code>链接器</td>
</tr>
<tr>
<td><a href="#-asflags">--asflags</a></td>
<td>设置<code>asm</code>汇编编译选项</td>
</tr>
<tr>
<td><a href="#-cflags">--cflags</a></td>
<td>设置<code>c</code>编译选项</td>
</tr>
<tr>
<td><a href="#-cxflags">--cxflags</a></td>
<td>设置<code>c/c++</code>编译选项</td>
</tr>
<tr>
<td><a href="#-cxxflags">--cxxflags</a></td>
<td>设置<code>c++</code>编译选项</td>
</tr>
<tr>
<td><a href="#-mflags">--mflags</a></td>
<td>设置<code>objc</code>编译选项</td>
</tr>
<tr>
<td><a href="#-mxflags">--mxflags</a></td>
<td>设置<code>objc/c++</code>编译选项</td>
</tr>
<tr>
<td><a href="#-mxxflags">--mxxflags</a></td>
<td>设置<code>objc++</code>编译选项</td>
</tr>
<tr>
<td><a href="#-scflags">--scflags</a></td>
<td>设置<code>swift</code>编译选项</td>
</tr>
<tr>
<td><a href="#-gcflags">--gcflags</a></td>
<td>设置<code>golang</code>编译选项</td>
</tr>
<tr>
<td><a href="#-dcflags">--dcflags</a></td>
<td>设置<code>dlang</code>编译选项</td>
</tr>
<tr>
<td><a href="#-rcflags">--rcflags</a></td>
<td>设置<code>rust</code>编译选项</td>
</tr>
<tr>
<td><a href="#-cuflags">--cuflags</a></td>
<td>设置<code>cuda</code>编译选项</td>
</tr>
<tr>
<td><a href="#-ldflags">--ldflags</a></td>
<td>设置链接选项</td>
</tr>
<tr>
<td><a href="#-shflags">--shflags</a></td>
<td>设置共享库链接选项</td>
</tr>
<tr>
<td><a href="#-arflags">--arflags</a></td>
<td>设置静态库归档选项</td>
</tr>
</tbody>
</table>
<p><p class="tip"><br>如果你想要了解更多参数选项，请运行: <code>xmake f --help</code>。<br></p>

</p>
<h6 id="sdk">--sdk</h6>
<ul>
<li>设置交叉工具链的sdk根目录</li>
</ul>
<p>大部分情况下，都不需要配置很复杂的toolchains前缀，例如：<code>arm-linux-</code> 什么的</p>
<p>只要这个工具链的sdk目录满足如下结构（大部分的交叉工具链都是这个结构）：</p>
<pre><code>/home/toolchains_sdkdir
   - bin
       - arm-linux-gcc
       - arm-linux-ld
       - ...
   - lib
       - libxxx.a
   - include
       - xxx.h
</code></pre><p>那么，使用xmake进行交叉编译的时候，只需要进行如下配置和编译：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir
$ xmake
</code></pre>
<p>这个时候，xmake会去自动探测，gcc等编译器的前缀名：<code>arm-linux-</code>，并且编译的时候，也会自动加上<code>链接库</code>和<code>头文件</code>的搜索选项，例如：</p>
<pre><code>-I/home/toolchains_sdkdir/include -L/home/toolchains_sdkdir/lib
</code></pre><p>这些都是xmake自动处理的，不需要手动配置他们。。</p>
<h6 id="bin">--bin</h6>
<ul>
<li>设置工具链bin目录</li>
</ul>
<p>对于不规则工具链目录结构，靠单纯地<a href="#-sdk">--sdk</a>选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的bin目录位置。</p>
<p>例如：一些特殊的交叉工具链的，编译器bin目录，并不在 <code>/home/toolchains_sdkdir/bin</code> 这个位置，而是独立到了 <code>/usr/opt/bin</code> </p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir --bin=/usr/opt/bin
$ xmake
</code></pre>
<p><p class="tip"><br>v2.2.1版本之前，这个参数名是<code>--toolchains</code>，比较有歧义，因此新版本中，统一改成<code>--bin=</code>来设置bin目录。<br></p>

</p>
<h6 id="cross">--cross</h6>
<ul>
<li>设置交叉工具链工具前缀</li>
</ul>
<p>像<code>aarch64-linux-android-</code>这种，通常如果你配置了<a href="#-sdk">--sdk</a>或者<a href="#-bin">--bin</a>的情况下，xmake会去自动检测的，不需要自己手动设置。</p>
<p>但是对于一些极特殊的工具链，一个目录下同时有多个cross前缀的工具bin混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个bin。</p>
<p>例如，toolchains的bin目录下同时存在两个不同的编译器：</p>
<pre><code>/opt/bin
 - armv7-linux-gcc
 - aarch64-linux-gcc
</code></pre><p>我们现在想要选用armv7的版本，则配置如下：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/toolsdk --bin=/opt/bin --cross=armv7-linux-
</code></pre>
<h6 id="as">--as</h6>
<ul>
<li>设置<code>asm</code>汇编器</li>
</ul>
<p>如果还要继续细分选择编译器，则继续追加相关编译器选项，例如：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --as=armv7-linux-as
</code></pre>
<p>如果存在<code>AS</code>环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p><p class="tip"><br>如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么编译器工具检测就会失败。<br>这个时候我们可以通过：<code>xmake f --as=gcc@/home/xxx/asmips.exe</code> 设置ccmips.exe编译器作为类gcc的使用方式来编译。<br>也就是说，在指定编译器为<code>asmips.exe</code>的同时，告诉xmake，它跟gcc用法和参数选项基本相同。<br></p>

</p>
<h6 id="cc">--cc</h6>
<ul>
<li>设置c编译器</li>
</ul>
<p>如果还要继续细分选择编译器，则继续追加相关编译器选项，例如：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cc=armv7-linux-clang
</code></pre>
<p>如果存在<code>CC</code>环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p><p class="tip"><br>如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么编译器工具检测就会失败。<br>这个时候我们可以通过：<code>xmake f --cc=gcc@/home/xxx/ccmips.exe</code> 设置ccmips.exe编译器作为类gcc的使用方式来编译。<br>也就是说，在指定编译器为<code>ccmips.exe</code>的同时，告诉xmake，它跟gcc用法和参数选项基本相同。<br></p>

</p>
<h6 id="cxx">--cxx</h6>
<ul>
<li>设置<code>c++</code>编译器</li>
</ul>
<p>如果还要继续细分选择编译器，则继续追加相关编译器选项，例如：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++
</code></pre>
<p>如果存在<code>CXX</code>环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p><p class="tip"><br>如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么编译器工具检测就会失败。<br>这个时候我们可以通过：<code>xmake f --cxx=clang++@/home/xxx/c++mips.exe</code> 设置c++mips.exe编译器作为类clang++的使用方式来编译。<br>也就是说，在指定编译器为<code>c++mips.exe</code>的同时，告诉xmake，它跟clang++用法和参数选项基本相同。<br></p>

</p>
<h6 id="ld">--ld</h6>
<ul>
<li>设置<code>c/c++/objc/asm</code>链接器</li>
</ul>
<p>如果还要继续细分选择链接器，则继续追加相关编译器选项，例如：</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ld=armv7-linux-clang++
</code></pre>
<p>如果存在<code>LD</code>环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p><p class="tip"><br>如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么链接器工具检测就会失败。<br>这个时候我们可以通过：<code>xmake f --ld=g++@/home/xxx/c++mips.exe</code> 设置c++mips.exe链接器作为类g++的使用方式来编译。<br>也就是说，在指定链接器为<code>c++mips.exe</code>的同时，告诉xmake，它跟g++用法和参数选项基本相同。<br></p>

</p>
<h6 id="sh">--sh</h6>
<ul>
<li>设置<code>c/c++/objc/asm</code>共享库链接器</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --sh=armv7-linux-clang++
</code></pre>
<p>如果存在<code>SH</code>环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p><p class="tip"><br>如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么链接器工具检测就会失败。<br>这个时候我们可以通过：<code>xmake f --sh=g++@/home/xxx/c++mips.exe</code> 设置c++mips.exe链接器作为类g++的使用方式来编译。<br>也就是说，在指定链接器为<code>c++mips.exe</code>的同时，告诉xmake，它跟g++用法和参数选项基本相同。<br></p>

</p>
<h6 id="ar">--ar</h6>
<ul>
<li>设置<code>c/c++/objc/asm</code>静态库归档器</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ar=armv7-linux-ar
</code></pre>
<p>如果存在<code>AR</code>环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p><p class="tip"><br>如果指定的编译器名不是那些xmake内置可识别的名字（带有ar等字样），那么链接器工具检测就会失败。<br>这个时候我们可以通过：<code>xmake f --ar=ar@/home/xxx/armips.exe</code> 设置armips.exe链接器作为类ar的使用方式来编译。<br>也就是说，在指定链接器为<code>armips.exe</code>的同时，告诉xmake，它跟ar用法和参数选项基本相同。<br></p>

</p>
<h4 id="">全局配置</h4>
<p>我们也可以将一些常用配置保存到全局配置中，来简化频繁地输入：</p>
<p>例如:</p>
<pre><code class="lang-bash">$ xmake g --ndk=~/files/android-ndk-r10e/
</code></pre>
<p>现在，我们重新配置和编译<code>android</code>程序：</p>
<pre><code class="lang-bash">$ xmake f -p android
$ xmake
</code></pre>
<p>以后，就不需要每次重复配置<code>--ndk=</code>参数了。</p>
<p><p class="tip"><br>    每个命令都有其简写，例如: <code>xmake g</code> 或者 <code>xmake global</code>.<br><br></p>

</p>
<h4 id="">清除配置</h4>
<p>有时候，配置出了问题编译不过，或者需要重新检测各种依赖库和接口，可以加上<code>-c</code>参数，清除缓存的配置，强制重新检测和配置</p>
<pre><code class="lang-bash">$ xmake f -c
$ xmake
</code></pre>
<p>或者：</p>
<pre><code class="lang-bash">$ xmake f -p iphoneos -c
$ xmake
</code></pre>
<h2 id="">语法说明</h2>
<p>xmake的工程描述文件xmake.lua虽然基于lua语法，但是为了使得更加方便简洁得编写项目构建逻辑，xmake对其进行了一层封装，使得编写xmake.lua不会像些makefile那样繁琐</p>
<p>基本上写个简单的工程构建描述，只需三行就能搞定，例如：</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<h4 id="">作用域</h4>
<p>xmake的描述语法是按作用域划分的，主要分为：</p>
<ul>
<li>外部作用域</li>
<li>内部作用域</li>
<li>接口作用域</li>
</ul>
<p>那哪些属于外部，哪些又属于内部呢，看看下面的注释，就知道个大概了：</p>
<pre><code class="lang-lua">-- 外部作用域
target("test")

    -- 外部作用域
    set_kind("binary")
    add_files("src/*.c")

    on_run(function ()
        -- 内部作用域
        end)

    after_package(function ()
        -- 内部作用域
        end)

-- 外部作用域
task("hello")

    -- 外部作用域
    on_run(function ()
        -- 内部作用域
        end)
</code></pre>
<p>简单的说，就是在自定义脚本<code>function () end</code>之内的都属于内部作用域，也就是脚本作用域，其他地方都是都属于于外部作用域。。</p>
<h5 id="">外部作用域</h5>
<p>对于大部分工程来说，并不需要很复杂的工程描述，也不需要自定义脚本支持，只需要简单的 <code>set_xxx</code> 或者 <code>add_xxx</code> 就能满足需求了</p>
<p>那么根据二八定律，80%的情况下，我们只需要这么写：</p>
<pre><code class="lang-lua">target("test")
    set_kind("static")
    add_files("src/test/*.c")

target("demo")
    add_deps("test")
    set_kind("binary")
    add_links("test")
    add_files("src/demo/*.c")
</code></pre>
<p>不需要复杂的api调用，也不需要各种繁琐的变量定义，以及 if 判断 和 for 循环，要的就是简洁可读，一眼看过去，就算不懂lua语法也没关系</p>
<p>就当做简单的描述语法，看上去有点像函数调用而已，会点编程的基本一看就知道怎么配置。</p>
<p>为了做到简洁、安全，在这个作用域内，很多lua 内置api是不开放出来的，尤其是跟写文件、修改操作环境相关的，仅仅提供一些基本的只读接口，和逻辑操作</p>
<p>目前外部作用域开放的lua内置api有：</p>
<ul>
<li>table</li>
<li>string</li>
<li>pairs</li>
<li>ipairs</li>
<li>print</li>
<li>os</li>
</ul>
<p>当然虽然内置lua api提供不多，但xmake还提供了很多扩展api，像描述api就不多说，详细可参考：<a href="https://xmake.io/#/zh/manual">API手册</a></p>
<p>还有些辅助api，例如：</p>
<p>dirs：扫描获取当前指定路径中的所有目录<br>files：扫描获取当前指定路径中的所有文件<br>format: 格式化字符串，string.format的简写版本</p>
<p>还有变量定义、逻辑操作也是可以使用的，毕竟是基于lua的，该有的基础语法，还是要有的，我们可以通过if来切换编译文件：</p>
<pre><code class="lang-lua">target("test")
    set_kind("static")
    if is_plat("iphoneos") then
        add_files("src/test/ios/*.c")
    else
        add_files("src/test/*.c")
    end
</code></pre>
<p>需要注意的是，变量定义分全局变量和局部变量，局部变量只对当前xmake.lua有效，不影响子xmake.lua</p>
<pre><code class="lang-lua">-- 局部变量，只对当前xmake.lua有效
local var1 = 0

-- 全局变量，影响所有之后 includes() 包含的子 xmake.lua 
var2 = 1

includes("src")
</code></pre>
<h5 id="">内部作用域</h5>
<p>也称插件、脚本作用域，提供更加复杂、灵活的脚本支持，一般用于编写一些自定义脚本、插件开发、自定义task任务、自定义模块等等</p>
<p>一般通过<code>function () end</code>包含，并且被传入到<code>on_xxx</code>, <code>before_xxx</code>和<code>after_xxx</code>接口内的，都属于自作用域。</p>
<p>例如：</p>
<pre><code class="lang-lua">-- 自定义脚本
target("hello")
    after_build(function ()
        -- 内部作用域
        end)

-- 自定义任务、插件
task("hello")
    on_run(function ()
        -- 内部作用域
        end)
</code></pre>
<p>在此作用域中，不仅可以使用大部分lua的api，还可以使用很多xmake提供的扩展模块，所有扩展模块，通过import来导入</p>
<p>具体可参考：<a href="https://xmake.io/#/zh/manual?id=import">import模块导入文档</a></p>
<p>这里我们给个简单的例子，在编译完成后，对ios目标程序进行ldid签名：</p>
<pre><code class="lang-lua">target("iosdemo")
    set_kind("binary")
    add_files("*.m")
    after_build(function (target) 

        -- 执行签名，如果失败，自动中断，给出高亮错误信息
        os.run("ldid -S$(projectdir)/entitlements.plist %s", target:targetfile())
    end)
</code></pre>
<p>需要注意的是，在内部作用域中，所有的调用都是启用异常捕获机制的，如果运行出错，会自动中断xmake，并给出错误提示信息</p>
<p>因此，脚本写起来，不需要繁琐的<code>if retval then</code>判断，脚本逻辑更加一目了然</p>
<h5 id="">接口作用域</h5>
<p>在外部作用域中的所有描述api设置，本身也是有作用域之分的，在不同地方调用，影响范围也不相同，例如：</p>
<pre><code class="lang-lua">-- 全局根作用域，影响所有target，包括includes() 中的子工程target设置
add_defines("DEBUG")

-- 定义或者进入demo目标作用域（支持多次进入来追加设置）
target("demo")
    set_kind("shared")
    add_files("src/*.c")
    -- 当前target作用域，仅仅影响当前target
    add_defines("DEBUG2")

-- 选项设置，仅支持局部设置，不受全局api设置所影响
option("test")
    -- 当前选项的局部作用域
    set_default(false)

-- 其他target设置，-DDEBUG 也会被设置上
target("demo2")
    set_kind("binary")
    add_files("src/*.c")

-- 重新进入demo目标作用域
target("demo")
    -- 追加宏定义，只对当前demo目标有效
    add_defines("DEBUG3")
</code></pre>
<p>通常情况下，进入另一个target/option域设置，会自动离开上个target/option域，但是有时候为了比较一些作用域污染情况，我们可以显示离开某个域，例如：</p>
<pre><code class="lang-lua">option("test")
    set_default(false)
option_end()

target("demo")
    set_kind("binary")
    add_files("src/*.c")
target_end()
</code></pre>
<p>调用<code>option_end()</code>, <code>target_end()</code>即可显式的离开当前target/option域设置。</p>
<h5 id="">作用域缩进</h5>
<p>xmake.lua里面缩进，只是个编写规范，用于更加清楚的区分，当前的设置 是针对 那个作用域的，虽然就算不缩进，也一样ok，但是可读性上 并不是很好。。</p>
<p>例如：</p>
<pre><code class="lang-lua">target("xxxx")
    set_kind("binary")
    add_files("*.c")
</code></pre>
<p>和</p>
<pre><code class="lang-lua">target("xxxx")
set_kind("binary")
add_files("*.c")
</code></pre>
<p>上述两种方式，效果上都是一样的，但是理解上，第一种更加直观，一看就知道<code>add_files</code>仅仅只是针对 target 设置的，并不是全局设置</p>
<p>因此，适当的进行缩进，有助于更好的维护xmake.lua</p>
<p>最后附上，tbox的<a href="https://github.com/tboox/tbox/blob/master/src/tbox/xmake.lua">xmake.lua</a>描述，仅供参考。。</p>
<h4 id="">语法简化</h4>
<p>xmake.lua的配置域语法，非常灵活，可以在相关域做各种复杂灵活的配置，但是对于许多精简的小块配置，这个时候就稍显冗余了：</p>
<pre><code class="lang-lua">option("test1")
    set_default(true)
    set_showmenu(true)
    set_description("test1 option")

option("test2")
    set_default(true)
    set_showmeu(true)

option("test3")
    set_default("hello")
</code></pre>
<p>xmake 2.2.6以上版本，对于上面的这些小块option域设置，我们可以简化下成单行描述：</p>
<pre><code class="lang-lua">option("test1", {default = true, showmenu = true, description = "test1 option"})
option("test2", {default = true, showmenu = true})
option("test3", {default = "hello"})
</code></pre>
<p>除了option域，对于其他域也是支持这种简化写法的，例如：</p>
<pre><code class="lang-lua">target("demo")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<p>简化为：</p>
<pre><code class="lang-lua">target("demo", {kind = "binary", files = "src/*.c"})
</code></pre>
<p>当然，如果配置需求比较复杂的，还是原有的多行设置方式更加方便，这个就看自己的需求来评估到底使用哪种方式了。</p>
<h2 id="">依赖包管理</h2>
<h4 id="">本地内置模式</h4>
<p>通过在项目中内置依赖包目录以及二进制包文件，可以方便的集成一些第三方的依赖库，这种方式比较简单直接，但是缺点也很明显，不方便管理。</p>
<p>以tbox工程为例，其依赖包如下：</p>
<pre><code>- base.pkg
- zlib.pkg
- polarssl.pkg
- openssl.pkg
- mysql.pkg
- pcre.pkg
- ...
</code></pre><p>如果要让当前工程识别加载这些包，首先要指定包目录路径，例如：</p>
<pre><code class="lang-lua">add_packagedirs("packages")
</code></pre>
<p>指定好后，就可以在target作用域中，通过<a href="https://xmake.io/#/zh/manual?id=targetadd_packages">add_packages</a>接口，来添加集成包依赖了，例如：</p>
<pre><code class="lang-lua">target("tbox")
    add_packages("zlib", "polarssl", "pcre", "mysql")
</code></pre>
<p>那么如何去生成一个*.pkg的包呢，如果是基于xmake的工程，生成方式很简单，只需要：</p>
<pre><code class="lang-console">$ cd tbox
$ xmake package
</code></pre>
<p>即可在build目录下生成一个tbox.pkg的跨平台包，给第三方项目使用，我也可以直接设置输出目录，编译生成到对方项目中去，例如：</p>
<pre><code class="lang-console">$ cd tbox
$ xmake package -o ../test/packages
</code></pre>
<p>这样，test工程就可以通过<a href="https://xmake.io/#/zh/manual?id=targetadd_packages">add_packages</a>和<a href="https://xmake.io/#/zh/manual?id=add_packagedirs">add_packagedirs</a>去配置和使用tbox.pkg包了。</p>
<p>关于内置包的详细描述，还可以参考下相关文章，这里面有详细介绍：<a href="https://tboox.org/cn/2016/08/06/add-package-and-autocheck/">依赖包的添加和自动检测机制</a></p>
<h4 id="">系统查找模式</h4>
<p>如果觉得上述内置包的管理方式非常不方便，可以通过xmake提供的内置接口<code>find_packages</code>。</p>
<p>目前此接口支持以下一些包管理支持：</p>
<ul>
<li>vcpkg</li>
<li>homebrew</li>
<li>pkg-config</li>
</ul>
<p>并且通过系统和第三方包管理工具进行依赖包的安装，然后与xmake进行集成使用，例如我们查找一个openssl包：</p>
<pre><code class="lang-lua">local packages = find_packages("openssl", "zlib")
</code></pre>
<p>返回的结果如下：</p>
<pre><code class="lang-lua">{
    {links = {"ssl", "crypto"}, linkdirs = {"/usr/local/lib"}, includedirs = {"/usr/local/include"}},
    {links = {"z"}, linkdirs = {"/usr/local/lib"}, includedirs = {"/usr/local/include"}}
}
</code></pre>
<p>如果查找成功，则返回一个包含所有包信息的table，如果失败返回nil</p>
<p>这里的返回结果可以直接作为<code>target:add</code>, <code>option:add</code>的参数传入，用于动态增加<code>target/option</code>的配置：</p>
<pre><code class="lang-lua">option("zlib")
    set_showmenu(true)
    before_check(function (option)
        option:add(find_packages("openssl", "zlib"))
    end)
</code></pre>
<pre><code class="lang-lua">target("test")
    on_load(function (target)
        target:add(find_package("openssl", "zlib"))
    end)
</code></pre>
<p>如果系统上装有<code>homebrew</code>, <code>pkg-config</code>等第三方工具，那么此接口会尝试使用它们去改进查找结果。</p>
<p>更完整的使用描述，请参考：<a href="https://xmake.io/#/zh/manual?id=find_packages">find_packages</a>接口文档。</p>
<h5 id="homebrew">homebrew集成支持</h5>
<p>由于homebrew一般都是把包直接装到的系统中去了，因此用户不需要做任何集成工作，<code>find_packages</code>就已经原生无缝支持。</p>
<h5 id="vcpkg">vcpkg集成支持</h5>
<p>目前xmake v2.2.2版本已经支持了vcpkg，用户只需要装完vcpkg后，执行<code>$ vcpkg integrate install</code>，xmake就能自动从系统中检测到vcpkg的根路径，然后自动适配里面包。</p>
<p>当然，我们也可以手动指定vcpkg的根路径来支持：</p>
<pre><code class="lang-console">$ xmake f --vcpkg=f:\vcpkg
</code></pre>
<p>或者我们可以设置到全局配置中去，避免每次切换配置的时候，重复设置：</p>
<pre><code class="lang-console">$ xmake g --vcpkg=f:\vcpkg
</code></pre>
<h4 id="">远程依赖模式</h4>
<p>这个在2.2.2版本后已经初步支持，用法上更加的简单，只需要设置对应的依赖包就行了，例如：</p>
<pre><code class="lang-lua">add_requires("tbox 1.6.*", "libpng ~1.16", "zlib")

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("tbox", "libpng", "zlib")
</code></pre>
<p>上面的<code>add_requires</code>用于描述当前项目需要的依赖包，而<code>add_packages</code>用于应用依赖包到test目标，只有设置这个才会自动追加links, linkdirs, includedirs等设置。</p>
<p>然后直接执行编译即可：</p>
<pre><code class="lang-console">$ xmake 
</code></pre>
<p>xmake会去远程拉取相关源码包，然后自动编译安装，最后编译项目，进行依赖包的链接，具体效果见下图：</p>
<p><img src="/assets/img/index/package_manage.png" width="80%" /></p>
<p>关于包依赖管理的更多相关信息和进展见相关issues：<a href="https://github.com/xmake-io/xmake/issues/69">Remote package management</a> </p>
<h5 id="">目前支持的特性</h5>
<ul>
<li>语义版本支持，例如：">= 1.1.0 < 1.2", "~1.6", "1.2.x", "1.*"</li>
<li>提供官方包仓库、自建私有仓库、项目内置仓库等多仓库管理支持</li>
<li>跨平台包编译集成支持（不同平台、不同架构的包可同时安装，快速切换使用）</li>
<li>debug依赖包支持，实现源码调试</li>
</ul>
<h5 id="">依赖包处理机制</h5>
<p>这里我们简单介绍下整个依赖包的处理机制：</p>
<p><img src="/assets/img/index/package_arch.png" width="80%" /></p>
<ol>
<li>优先检测当前系统目录、第三方包管理下有没有存在指定的包，如果有匹配的包，那么就不需要下载安装了 （当然也可以设置不使用系统包）</li>
<li>检索匹配对应版本的包，然后下载、编译、安装（注：安装在特定xmake目录，不会干扰系统库环境）</li>
<li>编译项目，最后自动链接启用的依赖包</li>
</ol>
<h5 id="">快速上手</h5>
<p>新建一个依赖tbox库的空工程：</p>
<pre><code class="lang-console">$ xmake create -t console_tbox test
$ cd test
</code></pre>
<p>执行编译即可，如果当前没有安装tbox库，则会自动下载安装后使用：</p>
<pre><code class="lang-console">$ xmake
</code></pre>
<p>切换到iphoneos平台进行编译，将会重新安装iphoneos版本的tbox库进行链接使用：</p>
<pre><code class="lang-console">$ xmake f -p iphoneos
$ xmake
</code></pre>
<p>切换到android平台arm64-v8a架构编译：</p>
<pre><code class="lang-console">$ xmake f -p android [--ndk=~/android-ndk-r16b]
$ xmake
</code></pre>
<h5 id="">语义版本设置</h5>
<p>xmake的依赖包管理是完全支持语义版本选择的，例如："~1.6.1"，对于语义版本的具体描述见：<a href="https://semver.org/">https://semver.org/</a></p>
<p>一些语义版本写法：</p>
<pre><code class="lang-lua">add_requires("tbox 1.6.*", "pcre 1.3.x", "libpng ^1.18")
add_requires("libpng ~1.16", "zlib 1.1.2 || >=1.2.11 <1.3.0")
</code></pre>
<p>目前xmake使用的语义版本解析器是<a href="https://github.com/uael">uael</a>贡献的<a href="https://github.com/uael/sv">sv</a>库，里面也有对版本描述写法的详细说明，可以参考下：<a href="https://github.com/uael/sv#versions">版本描述说明</a></p>
<p>当然，如果我们对当前的依赖包的版本没有特殊要求，那么可以直接这么写：</p>
<pre><code class="lang-lua">add_requires("tbox", "libpng", "zlib")
</code></pre>
<p>这会使用已知的最新版本包，或者是master分支的源码编译的包，如果当前包有git repo地址，我们也能指定特定分支版本：</p>
<pre><code class="lang-lua">add_requires("tbox master")
add_requires("tbox dev")
</code></pre>
<h5 id="">额外的包信息设置</h5>
<h6 id="">可选包设置</h6>
<p>如果指定的依赖包当前平台不支持，或者编译安装失败了，那么xmake会编译报错，这对于有些必须要依赖某些包才能工作的项目，这是合理的。<br>但是如果有些包是可选的依赖，即使没有也可以正常编译使用的话，可以设置为可选包：</p>
<pre><code class="lang-lua">add_requires("tbox", {optional = true})
</code></pre>
<h6 id="">禁用系统库</h6>
<p>默认的设置，xmake会去优先检测系统库是否存在（如果没设置版本要求），如果用户完全不想使用系统库以及第三方包管理提供的库，那么可以设置：</p>
<pre><code class="lang-lua">add_requires("tbox", {system = false})
</code></pre>
<h6 id="">使用调试版本的包</h6>
<p>如果我们想同时源码调试依赖包，那么可以设置为使用debug版本的包（当然前提是这个包支持debug编译）：</p>
<pre><code class="lang-lua">add_requires("tbox", {debug = true})
</code></pre>
<p>如果当前包还不支持debug编译，可在仓库中提交修改编译规则，对debug进行支持，例如：</p>
<pre><code class="lang-lua">package("openssl")
    on_install("linux", "macosx", function (package)
        os.vrun("./config %s --prefix=\"%s\"", package:debug() and "--debug" or "", package:installdir())
        os.vrun("make -j4")
        os.vrun("make install")
    end)
</code></pre>
<h6 id="">传递额外的编译信息到包</h6>
<p>某些包在编译时候有各种编译选项，我们也可以传递进来，当然包本身得支持：</p>
<pre><code class="lang-lua">add_requires("tbox", {configs = {small=true}})
</code></pre>
<p>传递<code>--small=true</code>给tbox包，使得编译安装的tbox包是启用此选项的。</p>
<h5 id="">第三方依赖包安装</h5>
<p>2.2.5版本之后，xmake支持对对第三方包管理器里面的依赖库安装支持，例如：conan，brew, vcpkg等</p>
<p>添加homebrew的依赖包：</p>
<pre><code class="lang-lua">add_requires("brew::zlib", {alias = "zlib"}})
add_requires("brew::pcre2/libpcre2-8", {alias = "pcre2"}})

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("pcre2", "zlib")
</code></pre>
<p>添加vcpkg的依赖包：</p>
<pre><code class="lang-lua">add_requires("vcpkg::zlib", "vcpkg::pcre2")

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("vcpkg::zlib", "vcpkg::pcre2")
</code></pre>
<p>添加conan的依赖包：</p>
<pre><code class="lang-lua">add_requires("CONAN::zlib/1.2.11@conan/stable", {alias = "zlib", debug = true})
add_requires("CONAN::OpenSSL/1.0.2n@conan/stable", {alias = "openssl", 
    configs = {options = "OpenSSL:shared=True"}})

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("openssl", "zlib")
</code></pre>
<p>执行xmake进行编译后：</p>
<pre><code class="lang-console">ruki:test_package ruki$ xmake
checking for the architecture ... x86_64
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.14
note: try installing these packages (pass -y to skip confirm)?
  -> CONAN::zlib/1.2.11@conan/stable  (debug)
  -> CONAN::OpenSSL/1.0.2n@conan/stable  
please input: y (y/n)

  => installing CONAN::zlib/1.2.11@conan/stable .. ok
  => installing CONAN::OpenSSL/1.0.2n@conan/stable .. ok

[  0%]: ccache compiling.release src/main.c
[100%]: linking.release test
</code></pre>
<h5 id="">使用自建私有包仓库</h5>
<p>如果需要的包不在官方仓库<a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a>中，我们可以提交贡献代码到仓库进行支持。<br>但如果有些包仅用于个人或者私有项目，我们可以建立一个私有仓库repo，仓库组织结构可参考：<a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>比如，现在我们有一个一个私有仓库repo：<a href="mailto:`git@github.com">`git@github.com</a>:myrepo/xmake-repo.git`</p>
<p>我们可以通过下面的命令进行仓库添加：</p>
<pre><code class="lang-console">$ xmake repo --add myrepo git@github.com:myrepo/xmake-repo.git
</code></pre>
<p>或者我们直接写在xmake.lua中：</p>
<pre><code class="lang-lua">add_repositories("my-repo git@github.com:myrepo/xmake-repo.git")
</code></pre>
<p>如果我们只是想添加一两个私有包，这个时候特定去建立一个git repo太小题大做了，我们可以直接把包仓库放置项目里面，例如：</p>
<pre><code>projectdir
  - myrepo
    - packages
      - t/tbox/xmake.lua
      - z/zlib/xmake.lua
  - src
    - main.c
  - xmake.lua
</code></pre><p>上面myrepo目录就是自己的私有包仓库，内置在自己的项目里面，然后在xmake.lua里面添加一下这个仓库位置：</p>
<pre><code class="lang-lua">add_repositories("my-repo myrepo")
</code></pre>
<p>这个可以参考<a href="https://github.com/tboox/benchbox">benchbox</a>项目，里面就内置了一个私有仓库。</p>
<p>我们甚至可以连仓库也不用建，直接定义包描述到项目xmake.lua中，这对依赖一两个包的情况还是很有用的，例如：</p>
<pre><code class="lang-lua">package("libjpeg")

    set_urls("http://www.ijg.org/files/jpegsrc.$(version).tar.gz")

    add_versions("v9c", "650250979303a649e21f87b5ccd02672af1ea6954b911342ea491f351ceb7122")

    on_install("windows", function (package)
        os.mv("jconfig.vc", "jconfig.h")
        os.vrun("nmake -f makefile.vc")
        os.cp("*.h", package:installdir("include"))
        os.cp("libjpeg.lib", package:installdir("lib"))
    end)

    on_install("macosx", "linux", function (package)
        import("package.tools.autoconf").install(package)
    end)

package_end()

add_requires("libjpeg")

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("libjpeg")
</code></pre>
<h5 id="">包管理命令使用</h5>
<p>包管理命令<code>$ xmake require</code> 可用于手动显示的下载编译安装、卸载、检索、查看包信息。</p>
<h6 id="">安装指定包</h6>
<pre><code class="lang-console">$ xmake require tbox
</code></pre>
<p>安装指定版本包：</p>
<pre><code class="lang-console">$ xmake require tbox "~1.6"
</code></pre>
<p>强制重新下载安装，并且显示详细安装信息：</p>
<pre><code class="lang-console">$ xmake require -f -v tbox "1.5.x"
</code></pre>
<p>传递额外的设置信息：</p>
<pre><code class="lang-console">$ xmake require --extra="debug=true,config={small=true}" tbox
</code></pre>
<p>安装debug包，并且传递<code>small=true</code>的编译配置信息到包中去。</p>
<h6 id="">卸载指定包</h6>
<pre><code class="lang-console">$ xmake require --uninstall tbox
</code></pre>
<p>这会完全卸载删除包文件。</p>
<h6 id="">查看包详细信息</h6>
<pre><code class="lang-console">$ xmake require --info tbox
</code></pre>
<h6 id="">在当前仓库中搜索包</h6>
<pre><code class="lang-console">$ xmake require --search tbox
</code></pre>
<p>这个是支持模糊搜素以及lua模式匹配搜索的：</p>
<pre><code class="lang-console">$ xmake require --search pcr
</code></pre>
<p>会同时搜索到pcre, pcre2等包。</p>
<h6 id="">列举当前已安装的包</h6>
<pre><code class="lang-console">$ xmake require --list
</code></pre>
<h5 id="">仓库管理命令使用</h5>
<p>上文已经简单讲过，添加私有仓库可以用（支持本地路径添加）：</p>
<pre><code class="lang-console">$ xmake repo --add myrepo git@github.com:myrepo/xmake-repo.git
</code></pre>
<p>v2.2.3开始，支持添加指定分支的repo，例如：</p>
<pre><code class="lang-console">$ xmake repo --add myrepo git@github.com:myrepo/xmake-repo.git dev
</code></pre>
<p>我们也可以移除已安装的某个仓库：</p>
<pre><code class="lang-console">$ xmake repo --remove myrepo
</code></pre>
<p>或者查看所有已添加的仓库：</p>
<pre><code class="lang-console">$ xmake repo --list
</code></pre>
<p>如果远程仓库有更新，可以手动执行仓库更新，来获取更多、最新的包：</p>
<pre><code class="lang-console">$ xmake repo -u
</code></pre>
<h5 id="">提交包到官方仓库</h5>
<p>目前这个特性刚完成不久，目前官方仓库的包还不是很多，有些包也许还不支持部分平台，不过这并不是太大问题，后期迭代几个版本后，我会不断扩充完善包仓库。</p>
<p>如果你需要的包，当前的官方仓库还没有收录，可以提交issues或者自己可以在本地调通后，贡献提交到官方仓库：<a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>详细的贡献说明，见：<a href="https://github.com/xmake-io/xmake-repo/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a></p>
<h2 id="">问答</h2>
<h4 id="">怎样获取更多参数选项信息？</h4>
<p>获取主菜单的帮助信息，里面有所有action和plugin的列表描述。</p>
<pre><code class="lang-bash">$ xmake [-h|--help]
</code></pre>
<p>获取配置菜单的帮助信息，里面有所有配置选项的描述信息，以及支持平台、架构列表。</p>
<pre><code class="lang-bash">$ xmake f [-h|--help]
</code></pre>
<p>获取action和plugin命令菜单的帮助信息，里面有所有内置命令和插件任务的参数使用信息。</p>
<pre><code class="lang-bash">$ xmake [action|plugin] [-h|--help]
</code></pre>
<p>例如，获取<code>run</code>命令的参数信息:</p>
<pre><code class="lang-bash">$ xmake run --help
</code></pre>
<h4 id="">怎样实现静默构建，不输出任何信息？</h4>
<pre><code class="lang-bash">$ xmake [-q|--quiet]
</code></pre>
<h4 id="xmake">如果xmake运行失败了怎么办？</h4>
<p>可以先尝试清除下配置，重新构建下：</p>
<pre><code class="lang-bash">$ xmake f -c
$ xmake
</code></pre>
<p>如果还是失败了，请加上 <code>-v</code> 或者 <code>--verbose</code> 选项重新执行xmake后，获取更加详细的输出信息</p>
<p>例如：</p>
<pre><code class="lang-hash">$ xmake [-v|--verbose] 
</code></pre>
<p>并且可以加上 <code>--backtrace</code> 选项获取出错时的xmake的调试栈信息, 然后你可以提交这些信息到<a href="https://github.com/xmake-io/xmake/issues">issues</a>.</p>
<pre><code class="lang-bash">$ xmake -v --backtrace
</code></pre>
<h4 id="">怎样看实时编译警告信息?</h4>
<p>为了避免刷屏，在构建时候，默认是不实时输出警告信息的，如果想要看的话可以加上<code>-w</code>选项启用编译警告输出就行了。</p>
<pre><code class="lang-bash">$ xmake [-w|--warning] 
</code></pre>
<h4 id="xmakelua">怎样基于源码自动生成xmake.lua</h4>
<p>如果你想临时写一两个测试代码、或者手上有一些移植过来的零散源码想要快速编译运行，可以不用专门xmake.lua，直接运行：</p>
<pre><code class="lang-bash">$ xmake
</code></pre>
<p>xmake会自动扫描分析当前的源码目录，识别程序结构和类型，生成一个xmake.lua，并且会尝试直接构建它。</p>
<p>如果编译成功，可以直接运行：</p>
<pre><code class="lang-bash">$ xmake run
</code></pre>
<p>当然，如果仅仅只是想要生成xmake.lua，默认不去构建，可以执行：</p>
<pre><code class="lang-bash">$ xmake f -y
</code></pre>
<p>更多相关介绍，请参考文章：<a href="https://tboox.org/cn/2017/01/07/build-without-makefile/">xmake新增智能代码扫描编译模式，无需手写任何make文件</a></p>
</article>
</body>
</html>